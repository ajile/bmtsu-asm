; Задача  e  = (a - c)^2 + 2 * a * c / k
;         e  = (5 - 2)^2 + 2 * 5 * 2 / 2
;         e  = 9 + 20 / 2
;         e  = 9 + 10
;         e  = 19
;
; t1 = (5 - 2)^2
; t1 = 9
;
; t2 = 2 * 5 * 2 / 2
; t2 = 20 / 2
; t2 = 10

extern _printf, exit

section .data
  A:       dw     5
  C:       dw     2
  K:       dw     2


; Раздел неинициализированных переменных
section .bss
  T1:    resw   1             ; Резервируем 1 слово, под результат выполнения программы
  T2:    resw   1             ; Резервируем 1 слово, под результат выполнения программы
  E:     resw   1             ; Резервируем 1 слово, под результат выполнения программы


; Начало секции кода
section .text
  global start
  start:

      ; Разобъем операцию на группы следующим образом (в соответсвии с
      ; приоритетами операций)
      ;
      ; e  = (a - c)^2 + 2 * a * c / k
      ;
      ; e = t1 + t2
      ; t1 = (a - c)^2
      ; t2 = 2 * a * c / k
      ;

      ; Сначала вычислим значение t1 = (a - c)^2

      mov    CX, [A]      ; Укладываем значение A в регистр CX
      sub    CX, [C]      ; Вычитаем из регистра CX значение C
      mov    AX, CX       ; Определяем операнд 1 для умножения
      mov    BX, CX       ; Определяем операнд 2 для умножения
      imul   BX           ; Перемножаем операнды

      ;
      ; На этом месте программы операция (a - c)^2 выполнена, а результат
      ; теперь хранится в AX. Результат обозначим как t1.
      ;
      ; Регистр EAX = 0x00000009
      ;
      ; Осталось выполнить:
      ; t1 = (a - c)^2;
      ; t1 + 2 * a * c / k
      ;

      mov    [T1], AX        ; Сохраняем результат в памяти - в самом конце он
                             ; нам понадобится

      ; Теперь вычисляем t2 = 2 * a * c / k

      mov    AX, 2          ; Определяем операнд 1 для умножения
      mov    BX, [A]        ; Определяем операнд 2 для умножения
      imul   BX             ; Перемножаем – к AX умножается BX

      ; Регистр EAX = 0X0000000A (т.е. 10)

      mov    BX, [C]        ; Определяем операнд 2 для умножения, первый операнд
                            ; уже есть в AX. Он равен 2 * A
      imul   BX             ; Перемножаем – (2 * A) * C

      ; Регистр EAX = 0x00000014 (т.е. 20)

      ; На этот момент операция 2 * a * c выполнена. Осталось поделить результат
      ; на K. Результат хранится в AX, осталось добавить второй операнд для
      ; операции деления.

      mov dl, [K]           ; Определяем второй аргумент для деления
      div dl                ; Делим AX на DL. Результат помещается в AX

      ; Регистр EAX = 0x0000000A (т.е. 10)

      mov    [T2], AX       ; Сохраняем результат в памяти - в самом конце он
                            ; нам понадобится

      ; На этот момент операция 2 * a * c / k выполнена. Теперь известны и t1 и
      ; t2. Осталось найти их сумму и результат поместить по адресу E переменной.
      ; e = t1 + t2

      mov    AX, [T1]
      add    AX, [T2]

      ; Регистр EAX = 0x00000013 (т.е. 19)

      mov    [E], AX        ; Укладываем результат в адрес E

      ; Вывод результата на экран ==============================================

      ; 

      ; Выход из программы, без ошибок =========================================

      mov    eax, 1       ; системный вызов № 1 — sys_exit
      xor    ebx, ebx     ; выход с кодом 0
      int    0x80         ; вызов ядра

     1                                  ; Задача  e  = (a - c)^2 + 2 * a * c / k
     2                                  ;         e  = (5 - 2)^2 + 2 * 5 * 2 / 2
     3                                  ;         e  = 9 + 20 / 2
     4                                  ;         e  = 9 + 10
     5                                  ;         e  = 19
     6                                  ;
     7                                  ; t1 = (5 - 2)^2
     8                                  ; t1 = 9
     9                                  ;
    10                                  ; t2 = 2 * 5 * 2 / 2
    11                                  ; t2 = 20 / 2
    12                                  ; t2 = 10
    13                                  
    14                                  extern _printf, exit
    15                                  
    16                                  section .data
    17 00000000 0500                      A:       dw     5
    18 00000002 0200                      C:       dw     2
    19 00000004 0200                      K:       dw     2
    20                                  
    21 00000006 48656C6C6F2C20776F-       msg:    db      "Hello, world!", 10
    21 0000000F 726C64210A         
    22                                    .len:   equ     $ - msg
    23                                  
    24                                  ; Раздел неинициализированных переменных
    25                                  section .bss
    26 00000000 <res 00000002>            T1:    resw   1             ; Резервируем 1 слово, под результат выполнения программы
    27 00000002 <res 00000002>            T2:    resw   1             ; Резервируем 1 слово, под результат выполнения программы
    28 00000004 <res 00000002>            E:     resw   1             ; Резервируем 1 слово, под результат выполнения программы
    29                                  
    30                                  ; Начало секции кода
    31                                  section .text
    32                                    global start
    33                                    start:
    34                                  
    35                                        ; Разобъем операцию на группы следующим образом (в соответсвии с
    36                                        ; приоритетами операций)
    37                                        ;
    38                                        ; e  = (a - c)^2 + 2 * a * c / k
    39                                        ;
    40                                        ; e = t1 + t2
    41                                        ; t1 = (a - c)^2
    42                                        ; t2 = 2 * a * c / k
    43                                        ;
    44                                  
    45                                        ; Сначала вычислим значение t1 = (a - c)^2
    46                                  
    47 00000000 668B0D[00000000]              mov    CX, [A]      ; Укладываем значение A в регистр CX
    48 00000007 662B0D[02000000]              sub    CX, [C]      ; Вычитаем из регистра CX значение C
    49 0000000E 6689C8                        mov    AX, CX       ; Определяем операнд 1 для умножения
    50 00000011 6689CB                        mov    BX, CX       ; Определяем операнд 2 для умножения
    51 00000014 66F7EB                        imul   BX           ; Перемножаем операнды
    52                                  
    53                                        ;
    54                                        ; На этом месте программы операция (a - c)^2 выполнена, а результат
    55                                        ; теперь хранится в AX. Результат обозначим как t1.
    56                                        ;
    57                                        ; Регистр EAX = 0x00000009
    58                                        ;
    59                                        ; Осталось выполнить:
    60                                        ; t1 = (a - c)^2;
    61                                        ; t1 + 2 * a * c / k
    62                                        ;
    63                                  
    64 00000017 66A3[00000000]                mov    [T1], AX        ; Сохраняем результат в памяти - в самом конце он
    65                                                               ; нам понадобится
    66                                  
    67                                        ; Теперь вычисляем t2 = 2 * a * c / k
    68                                  
    69 0000001D 66B80200                      mov    AX, 2          ; Определяем операнд 1 для умножения
    70 00000021 668B1D[00000000]              mov    BX, [A]        ; Определяем операнд 2 для умножения
    71 00000028 66F7EB                        imul   BX             ; Перемножаем – к AX умножается BX
    72                                  
    73                                        ; Регистр EAX = 0X0000000A (т.е. 10)
    74                                  
    75 0000002B 668B1D[02000000]              mov    BX, [C]        ; Определяем операнд 2 для умножения, первый операнд
    76                                                              ; уже есть в AX. Он равен 2 * A
    77 00000032 66F7EB                        imul   BX             ; Перемножаем – (2 * A) * C
    78                                  
    79                                        ; Регистр EAX = 0x00000014 (т.е. 20)
    80                                  
    81                                        ; На этот момент операция 2 * a * c выполнена. Осталось поделить результат
    82                                        ; на K. Результат хранится в AX, осталось добавить второй операнд для
    83                                        ; операции деления.
    84                                  
    85 00000035 8A15[04000000]                mov dl, [K]           ; Определяем второй аргумент для деления
    86 0000003B F6F2                          div dl                ; Делим AX на DL. Результат помещается в AX
    87                                  
    88                                        ; Регистр EAX = 0x0000000A (т.е. 10)
    89                                  
    90 0000003D 66A3[02000000]                mov    [T2], AX       ; Сохраняем результат в памяти - в самом конце он
    91                                                              ; нам понадобится
    92                                  
    93                                        ; На этот момент операция 2 * a * c / k выполнена. Теперь известны и t1 и
    94                                        ; t2. Осталось найти их сумму и результат поместить по адресу E переменной.
    95                                        ; e = t1 + t2
    96                                  
    97 00000043 66A1[00000000]                mov    AX, [T1]
    98 00000049 660305[02000000]              add    AX, [T2]
    99                                  
   100                                        ; Регистр EAX = 0x00000013 (т.е. 19)
   101                                  
   102 00000050 66A3[04000000]                mov    [E], AX        ; Укладываем результат в адрес E
   103                                  
   104                                        ; Вывод результата на экран ==============================================
   105                                  
   106 00000056 83EC0C                        sub ESP, 12
   107 00000059 C70424[04000000]              mov dword[ESP], E
   108 00000060 E8(00000000)                  call _printf
   109                                        ; add ESP, 12
   110                                        ; mov eax, "A"
   111                                        ; push eax
   112                                  
   113                                        ; Выход из программы, без ошибок =========================================
   114                                  
   115 00000065 B801000000                    mov    eax, 1       ; системный вызов № 1 — sys_exit
   116 0000006A 31DB                          xor    ebx, ebx     ; выход с кодом 0
   117 0000006C CD80                          int    0x80         ; вызов ядра
   118                                  
